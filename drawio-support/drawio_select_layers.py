#!/usr/bin/python3
"""
This script modifies the visibility of layers in the XML
file with diagram generated by drawio.

It works around the problem of lack of a possibility to export
only the selected layers from the CLI version of drawio.

Written by Wojciech M. Zabolotny 6.10.2022
(wzab01<at>gmail.com or wojciech.zabolotny<at>pw.edu.pl)

The code is published under LGPL V2 license
"""
from lxml import etree as let
import xml.etree.ElementTree as et
import xml.parsers.expat as pe
from io import StringIO
import os
import sys
import shutil
import zlib
import argparse

PARSER = argparse.ArgumentParser()
PARSER.add_argument("--layers", help="Selected layers, \"all\", comma separated list of integers or integer ranges like \"0-3,6,7\"", default="all")
PARSER.add_argument("--layer_prefix", help="Layer name prefix", default="Layer_")
PARSER.add_argument("--outfile", help="Output file", default="output.drawio")
PARSER.add_argument("--infile", help="Input file", default="input.drawio")
ARGS = PARSER.parse_args()

INFILENAME = ARGS.infile
OUTFILENAME = ARGS.outfile

# Find all elements with 'value' starting with the layer prefix.
# Return tuples with the element and the rest of 'value' after the prefix.
def find_layers(el_start):
    res = []
    for el in el_start:
        val = el.get('value')
        if val is not None:
            if val.find(ARGS.layer_prefix) == 0:
                # This is a layer element. Add it, and its name 
                # after the prefix to the list.
                res.append((el,val[len(ARGS.layer_prefix):]))
                continue
        # If it is not a layer element, scan its children
        res.extend(find_layers(el))
    return res

# Analyse the list of visible layers, and create the list
# of layers that should be visible. Customize this part
# if you want a more sophisticate method for selection
# of layers.
# Now only "all", comma separated list of integers
# or ranges of integers are supported.

def build_visible_list(layers):
    if layers == "all":
       return layers
    res = []
    for lay in layers.split(','):
        # Is it a range?
        s = lay.find("-")
        if s > 0:
            # This is a range
            first = int(lay[:s])
            last = int(lay[(s+1):])
            res.extend(range(first,last+1))
        else:
            res.append(int(lay))    
    return res

def is_visible(layer_tuple,visible_list):
    if visible_list == "all":
        return True
    if int(layer_tuple[1]) in visible_list:
        return True

try:
    EL_ROOT = et.fromstring(open(INFILENAME,"r").read())
except et.ParseError as perr:
    # Handle the parsing error
    ROW, COL = perr.position
    print(
        "Parsing error "
        + str(perr.code)
        + "("
        + pe.ErrorString(perr.code)
        + ") in column "
        + str(COL)
        + " of the line "
        + str(ROW)
        + " of the file "
        + INFILENAME
    )
    sys.exit(1)

visible_list = build_visible_list(ARGS.layers)

layers = find_layers(EL_ROOT)
for layer_tuple in layers:
    if is_visible(layer_tuple,visible_list):
        print("set "+layer_tuple[1]+" to visible")
        layer_tuple[0].attrib['visible']="1"
    else:
        print("set "+layer_tuple[1]+" to invisible")
        layer_tuple[0].attrib['visible']="0"

# Now write the modified file
t=et.ElementTree(EL_ROOT)
with open(OUTFILENAME, 'w') as f:
    t.write(f, encoding='unicode')

